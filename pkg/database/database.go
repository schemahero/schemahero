package database

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/pkg/errors"
	schemasv1alpha4 "github.com/schemahero/schemahero/pkg/apis/schemas/v1alpha4"
	"github.com/schemahero/schemahero/pkg/client/schemaheroclientset/scheme"
	"github.com/schemahero/schemahero/pkg/database/cassandra"
	"github.com/schemahero/schemahero/pkg/database/mysql"
	"github.com/schemahero/schemahero/pkg/database/postgres"
	"github.com/schemahero/schemahero/pkg/database/rqlite"
	"github.com/schemahero/schemahero/pkg/database/sqlite"
	"github.com/schemahero/schemahero/pkg/database/timescaledb"
	"github.com/schemahero/schemahero/pkg/database/types"
	"github.com/schemahero/schemahero/pkg/logger"
	"go.uber.org/zap"
	"gopkg.in/yaml.v2"
)

type Database struct {
	InputDir       string
	OutputDir      string
	Driver         string
	URI            string
	Hosts          []string
	Username       string
	Password       string
	Keyspace       string
	DeploySeedData bool
}

func (d *Database) CreateFixturesSync() error {
	logger.Info("generating fixtures",
		zap.String("input-dir", d.InputDir))

	statements := []string{}
	handleFile := func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() {
			return nil
		}

		fileData, err := ioutil.ReadFile(filepath.Join(d.InputDir, info.Name()))
		if err != nil {
			return err
		}

		var spec *schemasv1alpha4.TableSpec

		parsedK8sObject := schemasv1alpha4.Table{}
		if err := yaml.Unmarshal(fileData, &parsedK8sObject); err == nil {
			if parsedK8sObject.Spec.Schema != nil {
				spec = &parsedK8sObject.Spec
			}
		}

		if spec == nil {
			plainSpec := schemasv1alpha4.TableSpec{}
			if err := yaml.Unmarshal(fileData, &plainSpec); err != nil {
				return err
			}

			spec = &plainSpec
		}

		if spec.Schema == nil {
			return nil
		}

		if d.Driver == "postgres" {
			if spec.Schema.Postgres == nil || spec.Schema.Postgres.IsDeleted {
				return nil
			}

			createStatements, err := postgres.CreateTableStatements(spec.Name, spec.Schema.Postgres)
			if err != nil {
				return err
			}

			statements = append(statements, createStatements...)
		} else if d.Driver == "mysql" {
			if spec.Schema.Mysql == nil || spec.Schema.Mysql.IsDeleted {
				return nil
			}

			createStatements, err := mysql.CreateTableStatements(spec.Name, spec.Schema.Mysql)
			if err != nil {
				return err
			}

			statements = append(statements, createStatements...)
		} else if d.Driver == "cockroachdb" {
			if spec.Schema.CockroachDB == nil || spec.Schema.CockroachDB.IsDeleted {
				return nil
			}

			createStatements, err := postgres.CreateTableStatements(spec.Name, spec.Schema.CockroachDB)
			if err != nil {
				return err
			}

			statements = append(statements, createStatements...)
		} else if d.Driver == "sqlite" {
			if spec.Schema.SQLite == nil || spec.Schema.SQLite.IsDeleted {
				return nil
			}

			createStatements, err := sqlite.CreateTableStatements(spec.Name, spec.Schema.SQLite)
			if err != nil {
				return err
			}

			statements = append(statements, createStatements...)
		} else if d.Driver == "rqlite" {
			if spec.Schema.RQLite == nil || spec.Schema.RQLite.IsDeleted {
				return nil
			}

			createStatements, err := rqlite.CreateTableStatements(spec.Name, spec.Schema.RQLite)
			if err != nil {
				return err
			}

			statements = append(statements, createStatements...)
		} else if d.Driver == "timescaledb" {
			if spec.Schema.TimescaleDB == nil || spec.Schema.TimescaleDB.IsDeleted {
				return nil
			}

			createStatements, err := timescaledb.CreateTableStatements(spec.Name, spec.Schema.TimescaleDB)
			if err != nil {
				return err
			}

			statements = append(statements, createStatements...)
		} else if d.Driver == "cassandra" {
			return errors.New("not implemented")
		}

		return nil
	}

	err := filepath.Walk(d.InputDir, handleFile)
	if err != nil {
		return err
	}

	output := strings.Join(statements, ";\n")
	if output != "" {
		output = output + ";\n"
	}
	output = fmt.Sprintf("/* Auto generated file. Do not edit by hand. This file was generated by SchemaHero. */\n\n%s\n", output)

	if _, err := os.Stat(d.OutputDir); os.IsNotExist(err) {
		os.MkdirAll(d.OutputDir, 0750)
	}

	err = ioutil.WriteFile(filepath.Join(d.OutputDir, "fixtures.sql"), []byte(output), 0600)
	if err != nil {
		return err
	}

	return nil
}

func (d *Database) PlanSyncFromFile(filename string, specType string) ([]string, error) {
	specContents, err := ioutil.ReadFile(filepath.Clean(filename))
	if err != nil {
		return nil, errors.Wrap(err, "failed to read file")
	}

	plan, err := d.PlanSync(specContents, specType)
	if err != nil {
		return nil, errors.Wrap(err, "failed to plan sync")
	}

	return plan, nil
}

func (d *Database) PlanSync(specContents []byte, specType string) ([]string, error) {
	// Try GVK first and fall back to plain spec for backwards compatibility
	plan, err := d.planGVKSync(specContents)
	if err == nil {
		return plan, nil
	}

	logger.Debugf("failed to plan using GVK, falling back on spec type parameter: %s", err)

	if specType == "table" {
		plan, err := d.planTableSync(specContents)
		if err != nil {
			return nil, errors.Wrapf(err, "failed to plan table sync")
		}
		return plan, nil
	} else if specType == "type" {
		plan, err := d.planTypeSync(specContents)
		if err != nil {
			return nil, errors.Wrapf(err, "failed to plan type sync")
		}
		return plan, nil
	} else if specType == "view" {
		plan, err := d.planViewSync(specContents)
		if err != nil {
			return nil, errors.Wrapf(err, "failed to plan view sync")
		}
		return plan, nil
	} else if specType == "extension" {
		plan, err := d.planExtensionSync(specContents)
		if err != nil {
			return nil, errors.Wrapf(err, "failed to plan extension sync")
		}
		return plan, nil
	}

	return nil, errors.New("unknown spec type")
}

func (d *Database) planGVKSync(specContents []byte) ([]string, error) {
	decode := scheme.Codecs.UniversalDeserializer().Decode

	obj, gvk, err := decode(specContents, nil, nil)
	if err != nil {
		return nil, errors.Wrap(err, "failed to decode spec")
	}

	if gvk.Group == "schemas.schemahero.io" && gvk.Version == "v1alpha4" && gvk.Kind == "Table" {
		table := obj.(*schemasv1alpha4.Table)
		plan, err := d.PlanSyncTableSpec(&table.Spec)
		if err != nil {
			return nil, errors.Wrapf(err, "failed to plan table %s", table.Name)
		}
		return plan, nil
	} else if gvk.Group == "schemas.schemahero.io" && gvk.Version == "v1alpha4" && gvk.Kind == "View" {
		view := obj.(*schemasv1alpha4.View)
		plan, err := d.PlanSyncViewSpec(&view.Spec)
		if err != nil {
			return nil, errors.Wrapf(err, "failed to plan view %s", view.Name)
		}
		return plan, nil
	} else if gvk.Group == "schemas.schemahero.io" && gvk.Version == "v1alpha4" && gvk.Kind == "DatabaseExtension" {
		extension := obj.(*schemasv1alpha4.DatabaseExtension)
		plan, err := d.PlanSyncDatabaseExtensionSpec(&extension.Spec)
		if err != nil {
			return nil, errors.Wrapf(err, "failed to plan extension %s", extension.Name)
		}
		return plan, nil
	} else {
		return nil, errors.Errorf("unknown gvk %s", gvk)
	}
}

func (d *Database) planTableSync(specContents []byte) ([]string, error) {
	parsedK8sObject := schemasv1alpha4.Table{}
	var spec *schemasv1alpha4.TableSpec
	if err := yaml.Unmarshal(specContents, &parsedK8sObject); err == nil {
		if parsedK8sObject.Spec.Schema != nil {
			spec = &parsedK8sObject.Spec
		}
	}

	if spec == nil {
		plainSpec := schemasv1alpha4.TableSpec{}
		if err := yaml.Unmarshal(specContents, &plainSpec); err != nil {
			return nil, errors.Wrap(err, "failed to unmarshal table spec")
		}

		spec = &plainSpec
	}

	plan, err := d.PlanSyncTableSpec(spec)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to plan table sync for %s", spec.Name)
	}

	return plan, nil
}

func (d *Database) planViewSync(specContents []byte) ([]string, error) {
	parsedK8sObject := schemasv1alpha4.View{}
	var spec *schemasv1alpha4.ViewSpec
	if err := yaml.Unmarshal(specContents, &parsedK8sObject); err == nil {
		if parsedK8sObject.Spec.Schema != nil {
			spec = &parsedK8sObject.Spec
		}
	}

	if spec == nil {
		plainSpec := schemasv1alpha4.ViewSpec{}
		if err := yaml.Unmarshal(specContents, &plainSpec); err != nil {
			return nil, errors.Wrap(err, "failed to unmarshal view spec")
		}

		spec = &plainSpec
	}

	plan, err := d.PlanSyncViewSpec(spec)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to plan view sync for %s", spec.Name)
	}

	return plan, nil
}

func (d *Database) SortSpecs(specs []types.Spec) {
	switch d.Driver {
	case "postgres", "timescaledb":
		sort.Sort(types.Specs(specs))
	}
}

func (d *Database) PlanSyncViewSpec(spec *schemasv1alpha4.ViewSpec) ([]string, error) {
	if spec.Schema == nil {
		return []string{}, nil
	}

	if d.Driver == "postgres" {
		return postgres.PlanPostgresView(d.URI, spec.Name, spec.Schema.Postgres)
	} else if d.Driver == "mysql" {
		return mysql.PlanMysqlView(d.URI, spec.Name, spec.Schema.Mysql)
	} else if d.Driver == "cockroachdb" {
		return postgres.PlanPostgresView(d.URI, spec.Name, spec.Schema.CockroachDB)
	} else if d.Driver == "sqlite" {
		return sqlite.PlanSqliteView(d.URI, spec.Name, spec.Schema.SQLite)
	} else if d.Driver == "rqlite" {
		return rqlite.PlanRQLiteView(d.URI, spec.Name, spec.Schema.RQLite)
	} else if d.Driver == "timescaledb" {
		return timescaledb.PlanTimescaleDBView(d.URI, spec.Name, spec.Schema.TimescaleDB)
	} else if d.Driver == "cassandra" {
		return cassandra.PlanCassandraView(d.Hosts, d.Username, d.Password, d.Keyspace, spec.Name, spec.Schema.Cassandra)
	}

	return nil, errors.New("unknown driver")
}
func (d *Database) PlanSyncTableSpec(spec *schemasv1alpha4.TableSpec) ([]string, error) {
	if spec.Schema == nil {
		return []string{}, nil
	}

	var seedData *schemasv1alpha4.SeedData
	if d.DeploySeedData {
		seedData = spec.SeedData
	}

	if d.Driver == "postgres" {
		return postgres.PlanPostgresTable(d.URI, spec.Name, spec.Schema.Postgres, seedData)
	} else if d.Driver == "mysql" {
		return mysql.PlanMysqlTable(d.URI, spec.Name, spec.Schema.Mysql, seedData)
	} else if d.Driver == "cockroachdb" {
		return postgres.PlanPostgresTable(d.URI, spec.Name, spec.Schema.CockroachDB, seedData)
	} else if d.Driver == "cassandra" {
		return cassandra.PlanCassandraTable(d.Hosts, d.Username, d.Password, d.Keyspace, spec.Name, spec.Schema.Cassandra, seedData)
	} else if d.Driver == "sqlite" {
		return sqlite.PlanSqliteTable(d.URI, spec.Name, spec.Schema.SQLite, seedData)
	} else if d.Driver == "rqlite" {
		return rqlite.PlanRqliteTable(d.URI, spec.Name, spec.Schema.RQLite, seedData)
	} else if d.Driver == "timescaledb" {
		return timescaledb.PlanTimescaleDBTable(d.URI, spec.Name, spec.Schema.TimescaleDB, seedData)
	}

	return nil, errors.Errorf("unknown database driver: %q", d.Driver)
}

func (d *Database) PlanSyncSeedData(spec *schemasv1alpha4.TableSpec) ([]string, error) {
	if spec.SeedData == nil {
		return []string{}, nil
	}

	if d.Driver == "postgres" {
		return postgres.SeedDataStatements(spec.Name, spec.Schema.Postgres, spec.SeedData)
	} else if d.Driver == "mysql" {
		return mysql.SeedDataStatements(spec.Name, spec.SeedData)
	} else if d.Driver == "cockroachdb" {
		return postgres.SeedDataStatements(spec.Name, spec.Schema.Postgres, spec.SeedData)
	} else if d.Driver == "cassandra" {
		return nil, errors.New("cassandra seed data is not implemented")
	} else if d.Driver == "sqlite" {
		return sqlite.SeedDataStatements(spec.Name, spec.SeedData)
	} else if d.Driver == "rqlite" {
		return rqlite.SeedDataStatements(spec.Name, spec.SeedData)
	} else if d.Driver == "timescaledb" {
		return timescaledb.SeedDataStatements(spec.Name, spec.Schema.TimescaleDB, spec.SeedData)
	}

	return nil, errors.Errorf("unknown database driver: %q", d.Driver)
}

func (d *Database) planTypeSync(specContents []byte) ([]string, error) {
	var spec *schemasv1alpha4.DataTypeSpec
	parsedK8sObject := schemasv1alpha4.DataType{}
	if err := yaml.Unmarshal(specContents, &parsedK8sObject); err == nil {
		if parsedK8sObject.Spec.Schema != nil {
			spec = &parsedK8sObject.Spec
		}
	}

	if spec == nil {
		plainSpec := schemasv1alpha4.DataTypeSpec{}
		if err := yaml.Unmarshal(specContents, &plainSpec); err != nil {
			return nil, errors.Wrap(err, "failed to unmarshal type sync spec")
		}

		spec = &plainSpec
	}

	return d.PlanSyncTypeSpec(spec)
}

func (d *Database) PlanSyncTypeSpec(spec *schemasv1alpha4.DataTypeSpec) ([]string, error) {
	if spec.Schema == nil {
		return []string{}, nil
	}

	if d.Driver == "cassandra" {
		return cassandra.PlanCassandraType(d.Hosts, d.Username, d.Password, d.Keyspace, spec.Name, spec.Schema.Cassandra)
	}

	return nil, errors.Errorf("planning types is not supported for driver %q", d.Driver)
}

func (d *Database) ApplySync(statements []string) error {
	if d.Driver == "postgres" {
		return postgres.DeployPostgresStatements(d.URI, statements)
	} else if d.Driver == "mysql" {
		return mysql.DeployMysqlStatements(d.URI, statements)
	} else if d.Driver == "cockroachdb" {
		return postgres.DeployPostgresStatements(d.URI, statements)
	} else if d.Driver == "cassandra" {
		return cassandra.DeployCassandraStatements(d.Hosts, d.Username, d.Password, d.Keyspace, statements)
	} else if d.Driver == "sqlite" {
		return sqlite.DeploySqliteStatements(d.URI, statements)
	} else if d.Driver == "rqlite" {
		return rqlite.DeployRqliteStatements(d.URI, statements)
	} else if d.Driver == "timescaledb" {
		return postgres.DeployPostgresStatements(d.URI, statements)
	}

	return errors.Errorf("unknown database driver: %q", d.Driver)
}

// Combine lines that don't terminate with a semicolon.
// Semicolon on the last line is optional.
func (d *Database) GetStatementsFromDDL(ddl string) []string {
	lines := strings.Split(ddl, "\n")

	statements := []string{}

	statement := ""
	for i, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		if i == len(lines)-1 || strings.HasSuffix(line, ";") {
			statement = statement + " " + line
			statements = append(statements, strings.TrimSpace(statement))
			statement = ""
		} else {
			statement = statement + " " + line
		}
	}

	if statement != "" {
		statements = append(statements, strings.TrimSpace(statement))
	}

	return statements
}
func (d *Database) planExtensionSync(specContents []byte) ([]string, error) {
	var spec *schemasv1alpha4.DatabaseExtensionSpec
	parsedK8sObject := schemasv1alpha4.DatabaseExtension{}
	if err := yaml.Unmarshal(specContents, &parsedK8sObject); err == nil {
		if parsedK8sObject.Spec.Database != "" {
			spec = &parsedK8sObject.Spec
		}
	}

	if spec == nil {
		plainSpec := schemasv1alpha4.DatabaseExtensionSpec{}
		if err := yaml.Unmarshal(specContents, &plainSpec); err != nil {
			return nil, errors.Wrap(err, "failed to unmarshal extension spec")
		}

		spec = &plainSpec
	}

	return d.PlanSyncDatabaseExtensionSpec(spec)
}

func (d *Database) PlanSyncDatabaseExtensionSpec(spec *schemasv1alpha4.DatabaseExtensionSpec) ([]string, error) {
	if d.Driver == "postgres" && spec.Postgres != nil {
		return postgres.CreateExtensionStatements([]*schemasv1alpha4.PostgresDatabaseExtension{spec.Postgres})
	}

	return nil, errors.Errorf("planning extensions is not supported for driver %q or extension type not specified", d.Driver)
}
